#!/usr/bin/env bash
# SLURM job script for one WarpX run (invoked as an array task).
# Do not call directly; use submit_warpx_array.sh

set -euo pipefail

# --- Required env from submit script ---
: "${CONDA_ENV:?Missing CONDA_ENV}"
: "${PARAMS_FILE:?Missing PARAMS_FILE}"
: "${COL_KEYS:?Missing COL_KEYS}"
: "${COL_UNITS:?Missing COL_UNITS}"
: "${INPUT_TEMPLATE:?Missing INPUT_TEMPLATE}"
: "${RUN_TITLE_PREFIX:?Missing RUN_TITLE_PREFIX}"
: "${RUN_ROOT:?Missing RUN_ROOT}"
: "${NTASKS:?Missing NTASKS}"
WARPX_EXE="${WARPX_EXE:-}"

# Resolve this task's parameter row (1-based)
LINE_NUM="${SLURM_ARRAY_TASK_ID:?Missing SLURM_ARRAY_TASK_ID}"
# Filter out comments/blanks the same way the submitter counted them
mapfile -t FILTERED < <(grep -v '^[[:space:]]*#' "$PARAMS_FILE" | sed '/^[[:space:]]*$/d')
if (( LINE_NUM < 1 || LINE_NUM > ${#FILTERED[@]} )); then
  echo "Task index $LINE_NUM out of range 1..${#FILTERED[@]}" >&2
  exit 2
fi
ROW="${FILTERED[$((LINE_NUM-1))]}"

# Read columns from the row into an array
read -r -a COLS <<< "$ROW"

# Decode key/unit lists
IFS=',' read -r -a KEYS <<< "$COL_KEYS"
IFS=',' read -r -a UNITS <<< "$COL_UNITS"

if (( ${#COLS[@]} < ${#KEYS[@]} )); then
  echo "Row $LINE_NUM has ${#COLS[@]} cols but ${#KEYS[@]} keys are configured." >&2
  exit 3
fi

# Attempt to auto-detect WarpX exe if not provided
if [[ -z "${WARPX_EXE}" ]]; then
  CAND=$(compgen -G "$HOME/warpx/build/bin/warpx.3d*" | head -n1 || true)
  if [[ -z "$CAND" ]]; then
    echo "Could not find warpx executable automatically. Set WARPX_EXE in submit_warpx_array.sh." >&2
    exit 4
  fi
  WARPX_EXE="$CAND"
fi

# Prepare run directory name (encode key=value snippets + idx)
shorten_unit() {
  case "$1" in
    "*nano")  echo "nm" ;;
    "*micro") echo "um" ;;
    "*GeV")   echo "GeV";;
    "")       echo ""   ;;
    *)        echo "${1//[*]/}" ;;
  esac
}

TAG="idx${LINE_NUM}"
for i in "${!KEYS[@]}"; do
  k="${KEYS[$i]}"
  # strip my_constants. prefix for brevity
  ks="${k#my_constants.}"
  v="${COLS[$i]}"
  u="$(shorten_unit "${UNITS[$i]}")"
  # make value filename-safe (replace '.' with 'p', '-' with 'm')
  vs="${v//./p}"; vs="${vs//-/_}"
  if [[ -n "$u" ]]; then
    TAG="${TAG}_${ks}-${vs}${u}"
  else
    TAG="${TAG}_${ks}-${vs}"
  fi
done

RUNDIR="${RUN_ROOT}/${RUN_TITLE_PREFIX}_${TAG}"
mkdir -p "$RUNDIR"

# Copy inputs & exe
INFILE_BASENAME="inputs_C3.txt"
cp "$INPUT_TEMPLATE" "${RUNDIR}/${INFILE_BASENAME}"
cp "$WARPX_EXE" "${RUNDIR}/"
chmod +x "${RUNDIR}/"warpx.3d*

# Activate conda env
# if [[ -f "$HOME/miniconda3/etc/profile.d/conda.sh" ]]; then
#   source "$HOME/miniconda3/etc/profile.d/conda.sh"
# else
#   # fallback: try conda base
#   source "$(conda info --base)/etc/profile.d/conda.sh"
# fi


set +u
source "$(conda info --base)/etc/profile.d/conda.sh"
conda activate "${CONDA_ENV}"
set -u


# Apply parameter overrides into the inputs file
edit_param () {
  local file="$1" key="$2" value="$3" unit="$4"
  # value may be numeric or string; unit may be empty or like *nano
  local rhs="${value}${unit}"
  # Replace the entire RHS of 'key = ...' (leading spaces allowed)
  # Use perl for robust in-place, multi-line, anchored at line-start
  perl -0777 -pe "s/^([[:space:]]*\Q${key}\E[[:space:]]*=\s*)\K.*$/${rhs}/m" -i "${file}"

}

for i in "${!KEYS[@]}"; do
  edit_param "${RUNDIR}/${INFILE_BASENAME}" "${KEYS[$i]}" "${COLS[$i]}" "${UNITS[$i]}"
done

# Record the parameters that produced this run
{
  echo "# Generated by warpx_job.sh on $(date)"
  echo "# SLURM_JOB_ID=${SLURM_JOB_ID:-}  SLURM_ARRAY_TASK_ID=${SLURM_ARRAY_TASK_ID:-}"
  echo "# From template: $INPUT_TEMPLATE"
  echo "# Executable: $(basename "$WARPX_EXE")"
  echo "# Keys: ${COL_KEYS}"
  echo "# Units: ${COL_UNITS}"
  echo "# Row $LINE_NUM: $ROW"
} > "${RUNDIR}/_params_used.txt"

cd "$RUNDIR"
export OMP_NUM_THREADS=1

# Prefer srun on S3DF; if it fails, try mpirun
EXE="./$(basename "$WARPX_EXE")"
INPUT="${INFILE_BASENAME}"

echo "Launching in ${RUNDIR} ..."
set -x
if srun --version >/dev/null 2>&1; then
  srun -n "${NTASKS}" "${EXE}" "${INPUT}"
else
  mpirun -np "${NTASKS}" "${EXE}" "${INPUT}"
fi
set +x
